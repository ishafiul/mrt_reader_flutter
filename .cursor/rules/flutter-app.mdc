---
description: 
globs: 
alwaysApply: false
---
# Flutter Architecture Guidelines

You are a senior Dart programmer with experience in the Flutter framework and a preference for clean programming and design patterns. Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Dart General Guidelines

### Basic Principles
- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using dynamic.
  - Create necessary types with `freezed` and JSON serializable.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature
- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions
- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data
- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes
- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions
- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing
- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Flutter Architecture

### Module-Based Clean Architecture
- Structure your project using module-based clean architecture:
  ```
  lib/
  ├── core/
  │   ├── constants/
  │   ├── error/
  │   ├── extensions/
  │   ├── network/
  │   ├── theme/
  │   └── utils/
  ├── modules/
  │   ├── module_name/
  │   │   ├── data/
  │   │   │   ├── datasources/
  │   │   │   │   ├── local/
  │   │   │   │   └── remote/
  │   │   │   ├── models/
  │   │   │   └── repositories/
  │   │   ├── domain/
  │   │   │   ├── entities/
  │   │   │   ├── repositories/
  │   │   │   └── usecases/
  │   │   └── presentation/
  │   │       ├── cubit/
  │   │       ├── pages/
  │   │       └── widgets/
  │   └── another_module/
  └── main.dart
  ```

### State Management - Always Use Cubit
- Use Bloc pattern with Cubit for state management
- Create state classes with `freezed` for immutability
- Follow a predictable state pattern:
  ```dart
  @freezed
  class ExampleState with _$ExampleState {
    const factory ExampleState({
      @Default([]) List<Entity> entities,
      @Default(false) bool isLoading,
      @jsonIgnore Either<Failure, SuccessType>? resultOrFailure,
    }) = _ExampleState;
    
    factory ExampleState.fromJson(Map<String, dynamic> json) =>
        _$ExampleStateFromJson(json);
        
    const ExampleState._();
    
    SuccessType? get result {
      return switch (resultOrFailure) {
        Right(value: final value) => value,
        _ => null,
      };
    }
  }
  ```

- Structure Cubit classes:
  ```dart
  @injectable
  class ExampleCubit extends Cubit<ExampleState> {
    ExampleCubit(this._repository) : super(const ExampleState());
    
    final ExampleRepository _repository;
    
    Future<void> fetchData() async {
      emit(state.copyWith(isLoading: true, resultOrFailure: null));
      final result = await _repository.getData();
      emit(state.copyWith(isLoading: false, resultOrFailure: result));
    }
  }
  ```

### Dependency Injection
- Use `get_it` with `injectable` for dependency injection
- Register components based on their lifecycle:
  ```dart
  @module
  abstract class AppModule {
    @singleton
    HttpClient get httpClient => HttpClient();
    
    @lazySingleton
    ApiClient get apiClient => ApiClient(get<HttpClient>());
    
    @injectable
    DataRepository get dataRepository => DataRepositoryImpl(get<ApiClient>());
  }
  ```

### Local Storage with Isar
- Use Isar for local database
- Define schemas as classes with Isar annotations
- Create repositories that abstract database operations
- Use transactions for complex operations

### API Communication
- Use `retrofit` for API communication
- Define API interfaces with retrofit annotations
- Implement error handling with Either pattern
  ```dart
  @RestApi(baseUrl: "https://api.example.com")
  abstract class ApiClient {
    @GET("/endpoint")
    Future<HttpResponse<ResponseModel>> getEndpoint();
  }
  ```

### Widget Structure
- Break down large widgets into smaller, focused widgets
- Utilize const constructors wherever possible to reduce rebuilds
- Keep widget trees flat to improve performance
- Use extension methods for widget customization

### Navigation
- Use AutoRoute for navigation
- Define routes in a centralized file
- Use typed routes with parameters

### Error Handling
- Use Either pattern for error handling
- Define custom Failure classes for different error types
- Handle errors at the appropriate level

### Testing
- Use the standard widget testing for Flutter
- Mock dependencies using Mockito or Mocktail
- Write integration tests for each API module
- Test Cubits with BlocTest

## Example Implementation

### State
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:your_app/core/error/failure.dart';
import 'package:your_app/core/utils/either.dart';
import 'package:your_app/modules/example/domain/entities/example_entity.dart';

part 'example_state.freezed.dart';
part 'example_state.g.dart';

@freezed
class ExampleState with _$ExampleState {
  const factory ExampleState({
    @Default([]) List<ExampleEntity> items,
    @Default(false) bool isLoading,
    @jsonIgnore Either<Failure, List<ExampleEntity>>? itemsOrFailure,
  }) = _ExampleState;

  factory ExampleState.fromJson(Map<String, dynamic> json) =>
      _$ExampleStateFromJson(json);

  const ExampleState._();

  List<ExampleEntity>? get successItems {
    return switch (itemsOrFailure) {
      Right(value: final value) => value,
      _ => null,
    };
  }
}
```

### Cubit
```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:injectable/injectable.dart';
import 'package:your_app/core/utils/either.dart';
import 'package:your_app/modules/example/domain/repositories/example_repository.dart';
import 'package:your_app/modules/example/presentation/cubit/example_state.dart';

@injectable
class ExampleCubit extends Cubit<ExampleState> {
  ExampleCubit(this._repository) : super(const ExampleState());

  final ExampleRepository _repository;

  Future<void> fetchItems() async {
    emit(state.copyWith(isLoading: true, itemsOrFailure: null));
    final result = await _repository.getItems();
    
    emit(state.copyWith(
      isLoading: false,
      itemsOrFailure: result,
      items: result.isRight ? result.rightOrThrow : state.items,
    ));
  }

  void updateItem(ExampleEntity item) {
    final items = List.of(state.items);
    final index = items.indexWhere((e) => e.id == item.id);
    
    if (index != -1) {
      items[index] = item;
      emit(state.copyWith(items: items));
    }
  }
}
```

### Repository
```dart
import 'package:injectable/injectable.dart';
import 'package:your_app/core/error/failure.dart';
import 'package:your_app/core/utils/either.dart';
import 'package:your_app/modules/example/data/datasources/local/example_local_datasource.dart';
import 'package:your_app/modules/example/data/datasources/remote/example_remote_datasource.dart';
import 'package:your_app/modules/example/domain/entities/example_entity.dart';
import 'package:your_app/modules/example/domain/repositories/example_repository.dart';

@Injectable(as: ExampleRepository)
class ExampleRepositoryImpl implements ExampleRepository {
  ExampleRepositoryImpl(this._remoteDatasource, this._localDatasource);

  final ExampleRemoteDatasource _remoteDatasource;
  final ExampleLocalDatasource _localDatasource;

  @override
  Future<Either<Failure, List<ExampleEntity>>> getItems() async {
    try {
      final remoteItems = await _remoteDatasource.getItems();
      await _localDatasource.cacheItems(remoteItems);
      return Right(remoteItems);
    } catch (e) {
      try {
        final localItems = await _localDatasource.getItems();
        return Right(localItems);
      } catch (e) {
        return Left(Failure('Failed to fetch items'));
      }
    }
  }
}
```

### Retrofit API Client
```dart
import 'package:dio/dio.dart';
import 'package:injectable/injectable.dart';
import 'package:retrofit/retrofit.dart';
import 'package:your_app/modules/example/data/models/example_model.dart';

part 'example_api_client.g.dart';

@RestApi()
@injectable
abstract class ExampleApiClient {
  @factoryMethod
  factory ExampleApiClient(Dio dio) = _ExampleApiClient;

  @GET('/examples')
  Future<HttpResponse<List<ExampleModel>>> getExamples();

  @GET('/examples/{id}')
  Future<HttpResponse<ExampleModel>> getExample(@Path('id') String id);

  @POST('/examples')
  Future<HttpResponse<ExampleModel>> createExample(@Body() ExampleModel example);
}
```

### Isar Database
```dart
import 'package:injectable/injectable.dart';
import 'package:isar/isar.dart';
import 'package:your_app/modules/example/data/models/example_model.dart';

@injectable
class ExampleDatabase {
  ExampleDatabase(this._isar);

  final Isar _isar;

  Future<List<ExampleModel>> getAll() async {
    return _isar.exampleModels.where().findAll();
  }

  Future<void> saveAll(List<ExampleModel> examples) async {
    await _isar.writeTxn(() async {
      await _isar.exampleModels.putAll(examples);
    });
  }

  Future<ExampleModel?> getById(String id) async {
    return _isar.exampleModels.filter().idEqualTo(id).findFirst();
  }

  Future<void> deleteAll() async {
    await _isar.writeTxn(() async {
      await _isar.exampleModels.clear();
    });
  }
}
```

### Getting Started with a New Module
1. Create the folder structure
2. Define entities and models
3. Create repository interfaces
4. Implement datasources
5. Implement repository
6. Create Cubit and state
7. Create UI components
8. Register dependencies